---Bitwise AND (&):
Syntax: a & b
Function: Performs a bitwise AND operation on each bit of its integer arguments. A bit is set in the result only if the corresponding bit is set in both operands.
Purpose: Used to clear specific bits (set them to 0).
Example_1: 5 & 3 (which is 0101 & 0011 in binary) results in 1 (0001).
Example_2: Clearing the least significant bit (LSB) of a number.
    Suppose num = 14 (which is 1110 in binary).
    To clear the LSB, use num & 13 (where 13 is 1101 in binary).
    Result: 14 & 13 = 1110 & 1101 = 1100 (which is 12 in decimal).


---Bitwise OR (|):
Syntax: a | b
Function: Performs a bitwise OR operation on each bit of its integer arguments. A bit is set in the result if the corresponding bit is set in one or both operands.
Purpose: Used to set specific bits (set them to 1).
Example_1: 5 | 3 (which is 0101 | 0011 in binary) results in 7 (0111).
Example_2: Setting the LSB of a number.
    Suppose num = 12 (which is 1100 in binary).
    To set the LSB, use num | 1 (where 1 is 0001 in binary).
    Result: 12 | 1 = 1100 | 0001 = 1101 (which is 13 in decimal).


---Bitwise XOR (^):
Syntax: a ^ b
Function: Performs a bitwise XOR (exclusive OR) operation on each bit of its integer arguments. A bit is set in the result if the corresponding bit is set in one and only one of the operands.
Purpose: Used to toggle specific bits.
Example_1: 5 ^ 3 (which is 0101 ^ 0011 in binary) results in 6 (0110).
Example_2: Toggling the LSB of a number.
    Suppose num = 14 (which is 1110 in binary).
    To toggle the LSB, use num ^ 1 (where 1 is 0001 in binary).
    Result: 14 ^ 1 = 1110 ^ 0001 = 1111 (which is 15 in decimal).


---Bitwise NOT (~):
Syntax: ~a
Function: Performs a bitwise NOT operation on each bit of its integer argument. It inverts each bit (turns 0 into 1 and 1 into 0).
Purpose: Used to invert all bits.
Example_1: ~5 (which is ~0101 in binary) results in -6 (assuming a 4-bit system for simplicity, would be 1010).
Example_2: Inverting all bits of a number.
    Suppose num = 5 (which is 0101 in binary).
    Inverting all bits, use ~num.
    Result: ~5 = ~0101 = 1010 (if we consider only the last 4 bits, this would be -6 in a signed 4-bit system).


---Left Shift (<<):
Syntax: a << n
Function: Shifts the bits of a to the left by n positions. Zeros are shifted in from the right. This operation effectively multiplies a by 2 to the power of n.
Purpose: Used for multiplying by powers of 2.
Example_1: 1 << 3 shifts the binary 0001 three positions to the left, resulting in 1000 (or 8 in decimal).
Example_2: Multiplying a number by 4.
    Suppose num = 3 (which is 0011 in binary).
    To multiply by 4, use num << 2.
    Result: 3 << 2 = 0011 << 2 = 1100 (which is 12 in decimal).


---Right Shift (>>):
Syntax: a >> n
Function: Shifts the bits of a to the right by n positions. For unsigned types, zeros are shifted in from the left. For signed types, it's implementation-defined whether zeros or sign bits are shifted in.
Purpose: Used for dividing by powers of 2 (taking care of sign for signed numbers).
Example_1: 8 >> 2 shifts the binary 1000 two positions to the right, resulting in 0010 (or 2 in decimal).
Example_2: Dividing a number by 2.
    Suppose num = 8 (which is 1000 in binary).
    To divide by 2, use num >> 1.
    Result: 8 >> 1 = 1000 >> 1 = 0100 (which is 4 in decimal).